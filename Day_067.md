# Day 67: Deploy Guest Book App on Kubernetes

The Nautilus Application development team has finished development of one of the applications and it is ready for deployment. It is a guestbook application that will be used to manage entries for guests/visitors. As per discussion with the DevOps team, they have finalized the infrastructure that will be deployed on Kubernetes cluster. Below you can find more details about it.

BACKEND TIER
* Create a deployment named `redis-master` for Redis master.

  * Replicas count should be `1`.
  * Container name should be `master-redis-nautilus` and it should use image `redis`.
  * Request resources as CPU should be `100m` and Memory should be `100Mi`.
  * Container port should be redis default port i.e `6379`.

* Create a service named `redis-master` for Redis master. Port and targetPort should be Redis default port i.e `6379`.

* Create another deployment named `redis-slave` for Redis slave.

  * Replicas count should be `2`.
  * Container name should be `slave-redis-nautilus` and it should use `gcr.io/google_samples/gb-redisslave:v3` image.
  * Requests resources as CPU should be `100m` and Memory should be `100Mi`.
  * Define an environment variable named `GET_HOSTS_FROM` and its value should be `dns`.
  * Container port should be Redis default port i.e `6379`.

* Create another service named `redis-slave`. It should use Redis default port i.e `6379`.

FRONTEND TIER
* Create a deployment named `frontend`.

  * Replicas count should be `3`.
  * Container name should be `php-redis-nautilus` and it should use `gcr.io/google-samples/gb-frontend@sha256:a908df8486ff66f2c4daa0d3d8a2fa09846a1fc8efd65649c0109695c7c5cbff` image.
  * Request resources as CPU should be `100m` and Memory should be `100Mi`.
  * Define an environment variable named as `GET_HOSTS_FROM` and its value should be `dns`.
  * Container port should be `80`.

* Create a service named `frontend`. Its type should be `NodePort`, port should be `80` and its nodePort should be `30009`.

Finally, you can check the guestbook app by clicking on App button.

You can use any labels as per your choice.

> Note: The kubectl utility on jump_host has been configured to work with the kubernetes cluster.


## Solution
1. On jump host, create `redis-master` deployment using below details
```sh
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: redis-master
  name: redis-master
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis-master
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: redis-master
    spec:
      containers:
      - image: redis
        name: master-redis-nautilus
        ports:
        - containerPort: 6379
        resources:
          requests:
            memory: "100Mi"
            cpu: "100m"
```

2. Create a service `redis-master` 
```sh
kubectl expose deployment redis-master --port 6379 --type ClusterIp --name=redis-master
```

3. Create `redis-slave` deployment using yaml details below
```sh
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: redis-slave
  name: redis-slave
spec:
  replicas: 2
  selector:
    matchLabels:
      app: redis-slave
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: redis-slave
    spec:
      containers:
      - image: gcr.io/google_samples/gb-redisslave:v3
        name: slave-redis-nautilus
        env:
        - name: GET_HOSTS_FROM
          value: dns
        ports:
        - containerPort: 6379
        resources:
          requests:
            memory: "100Mi"
            cpu: "100m"
```

4. Create a service `redis-slave` 
```sh
kubectl expose deployment redis-slave --port 6379 --type ClusterIp --name=redis-slave
```

5. Create `frontend` deployment using yaml file details below
```sh
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: frontend
  name: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: frontend
    spec:
      containers:
      - image: gcr.io/google-samples/gb-frontend@sha256:a908df8486ff66f2c4daa0d3d8a2fa09846a1fc8efd65649c0109695c7c5cbff
        name: php-redis-nautilus
        env:
        - name: GET_HOSTS_FROM
          value: dns
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "100Mi"
            cpu: "100m"
```

6. Create a service `redis-master` 
```sh
kubectl expose deployment frontend --port 80 --type NodePort --name=frontend
kubectl edit service frontend
```
> Update NodePort to 30009


7. Verify the deployemnts and pods are in running state
```sh
kubectl get deploy
kubectl get pods
kubectl exec pods <pod-name> -it -c php-redis-nautilus -- curl http://localhost:80
```
